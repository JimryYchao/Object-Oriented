# 对象模型

---

- [对象模型](#对象模型)
- [1. 对象模型的演进](#1-对象模型的演进)
	- [1.1 程序设计语言的换代](#11-程序设计语言的换代)
	- [1.2 第一代和第二代早期程序设计语言的拓扑结构](#12-第一代和第二代早期程序设计语言的拓扑结构)
	- [1.3 第二代后期和第三代早期程序设计语言的结构](#13-第二代后期和第三代早期程序设计语言的结构)
	- [1.4 第三代后期程序设计语言的结构](#14-第三代后期程序设计语言的结构)
	- [1.5 基于对象和面向对象的程序设计语言的结构](#15-基于对象和面向对象的程序设计语言的结构)
- [2. 对象模型基础](#2-对象模型基础)
	- [2.1 面向对象编程](#21-面向对象编程)
	- [2.2 面向对象设计](#22-面向对象设计)
	- [2.3 面向对象分析](#23-面向对象分析)
- [3. 对象模型要素](#3-对象模型要素)
	- [3.1 抽象的意义](#31-抽象的意义)
	- [3.2 封装的意义](#32-封装的意义)
	- [3.3 模块化的意义](#33-模块化的意义)
	- [3.4 层次结构的意义](#34-层次结构的意义)
	- [3.5 类型的意义](#35-类型的意义)
	- [3.6 并发的意义](#36-并发的意义)
	- [3.7 持久的意义](#37-持久的意义)
- [4. 应用对象模型](#4-应用对象模型)

---
# 1. 对象模型的演进

## 1.1 程序设计语言的换代

- 第一代语言：1954 ~ 1958
- 第二代语言：1959 ~ 1961
- 第三代语言：1962 ~ 1970
- 代沟：1970 ~ 1980，C 语言
- 面向对象兴盛：1980~1990，C++
- 框架的出现：1990 ~ 至今，C#，Java

---
## 1.2 第一代和第二代早期程序设计语言的拓扑结构

- 拓扑结构：表示为这种语言的基本物理构成单位，这些语言编写的应用展现相对较平的物理结构，只包含全局数据和子程序。
- 这些语言构成的大型系统常常会包含子程序间的大量交叉耦合、对数据含义的假定及复杂的控制流。

---
## 1.3 第二代后期和第三代早期程序设计语言的结构

- 首次出现软件抽象，而子程序逐渐被认为是抽象程序功能的一种方式。
- 首先，人们开始发明一些语言，支持各种参数传递机制；其次，奠定了结构化程序设计的基础，表明在语言上支持嵌套的子程序，并在控制结构和声明的可见性范围方面发展了一些理论；最后，出现了结构化设计方法，利用子程序作为基本构建块
  
---
## 1.4 第三代后期程序设计语言的结构

- 大规模编程项目的出现意味着大型的开发团队，因此需要独立地开发同一个程序的不同部分。因此出现了能够独立编译的模块，但在早期的概念中只是一种随意的数据和子程序的容器
- 大多数语言支持某些模块化结构，但很少有规则要求模块间接口的语义一致性

---
## 1.5 基于对象和面向对象的程序设计语言的结构

- 通过过程可以实现的抽象本质上很适合描述抽象操作，但并不适合描述抽象的对象。在许多应用中，要操作的数据对象的复杂性在很大程度上决定了问题的复杂性
- 首先出现了关于数据驱动的方法，为面向对象语言提供了一种解决数据抽象问题的方法；其次出现了类型概念的理论。
- 这类语言的构建块是模块，表现为逻辑上的一组类或对象，而不是早期语言的子程序。
- 数据和操作被放在一个单元中，系统的基本逻辑构建不再是算法，而是类或对象

---
# 2. 对象模型基础

- 结构化的设计方法指导开发者利用算法作为基本构建块来构建复杂系统。类似地，面向对象设计方法利用类和对象作为基本构建块，指导开发者探索基于对象和面向对象编程语言的表现力。

---
## 2.1 面向对象编程

- 面向对象编程是一种实现的方法：程序被组织成许多组相互协作的对象，每个对象代表某个类的一个实例，而类则属于一个通过继承关系形成的层次结构

> 定义有三个要点

- 利用对象作为面向对象编程的基本逻辑构建块，而不是利用算法
- 每个对象都是某个类的一个实例
- 类与类之间可以通过继承关系联系在一起

> 当且仅当一种语言满足以下需求时，它才是面向对象的

- 它支持对象，这些对象是具有命名的操作接口和隐藏的内部状态的数据抽象
- 对象有相关的类型（类）
- 类型（类）可以从超类型（类）中继承属性

---
## 2.2 面向对象设计

- 面向对象设计是一种设计方法：包括面向对象分解的过程和一种表示法，这种表示法用于展现被设计系统的逻辑模型和物理模型、静态模型和动态模型

> 定义有两个要点

- 面向对象设计导致了面向对象分解
- 面向对象设计使用了不同的表示法来表达系统逻辑设计（类和对象结构）和物理设计（模块和处理架构）的不同模型，以及系统的静态和动态特征

---
## 2.3 面向对象分析

- 面向对象分析是一种分析方法：这种方法利用从问题域的词汇表中找到的类和对象来分析需求
- 面向对象分析的重点在于构建真实世界的模型，利用面向对象的观点来看世界
  
---
# 3. 对象模型要素

> 存在的五种主要的编程风格

- 面向过程：算法，适合设计计算密集的操作
- 面向对象：类和对象，适合作为系统架构，被其他风格编程所使用
- 面向逻辑：目标，通常以谓词演算的方式表示
- 面向规则：如果—那么规则，适合设计知识库
- 面向约束：不变的关系

---
## 3.1 抽象的意义

- 抽象是人类处理复杂性的基本方式：抽象来自于对真实世界中特定对象、场景或处理的相似性的认知，并决定关注这些相似性而忽略不同之处
- “最少惊奇” 原则：指抽象捕捉了某个对象的全部行为，不多也不少，并且不提供抽象之外的惊奇效果或副作用。对象的接口只提供它的基本行为。

> 抽象的定义

- 抽象描述了一个对象的基本特征：可以将这个对象与所有其他类型的对象区分开来，因此提供了清晰定义的概念边界，它与观察者的视角有关

> 一系列的抽象

- 实体抽象：代表了问题域或解决方案域实体的一个有用的模型
- 动作抽象：提供了一组通用的操作，所有这些操作都执行同类的功能
- 虚拟机抽象：集中了某中高层控制要用到的所有操作，或者这些操作将利用某种更低层的操作集
- 偶然抽象：封装了一组相互间没有关系的操作

> 客户对象是使用其他对象（服务器对象）的资源的对象

- 编程契约模型：每个对象的外部视图定义了一份契约，其他对象可以依赖于这份契约，而该对象则需要通过它的内部视图来实现这份契约
- 客户对象调用对象的整个操作集，利用两者之间契约关系，按照这些操作合法的调用顺序构成的协议，构成了抽象的完整静态和动态外部视图

> 抽象思想的核心是不变性的概念

- 对于对象的每个操作，定义前置条件和后置条件。违反前置条件，意味着客户对象没有完成它的责任，服务器将不能可靠地执行；违反后置条件，服务器没有完成它的部分责任，客户不能再信任服务器的行为。
- 违反一个不变量将破坏一个抽象相关的契约，程序常常表现为异常。一些语言允许对象抛出异常，向其他对象报告问题，这些对象就可以捕捉异常并处理问题。

> 所有的抽象都有静态和动态的属性

- 在面向过程风格的编程中，改变的动作和对象的动态值是所有程序的中心部分。
- 在面向规则风格的编程中，当新的事件触发了规则，事情就发生了，它又可以进一步触发其他规则。
- 在面向对象风格的编程中，到操作一个对象时，事情就发生了

---
## 3.2 封装的意义

> 抽象和封装是互补的概念

- 抽象关注对象的可以观察到的行为，封装关注这种行为的实现
- 封装通常是通过信息隐藏来实现的，信息隐藏是将那些不涉及对象本质特征的秘密都隐藏起来的过程。
- 复杂系统的每一个部分都不应该依赖于其他部分的内部细节
- 封装在不同的抽象之间提供了明确的边界，因此导致了清晰的分离关注；要让抽象工作，就必须将实现封装起来

> 封装的定义

- 封装是一个过程，它分隔构成抽象的结构和行为的元素。封装的作用是分离抽象的概念接口及其实现

---
## 3.3 模块化的意义

- 将一个程序分割到一些不同的组件中，可以在某种程度上减少它的复杂性
- 模块化将程序划分为一些模块，这些模块可以独立地编译，但又与其他模块有联系
- 对于很小的问题来说，开发者可能决定将所有的类和对象都声明在一个包中；对于稍微有点实际意义的软件来说，更好的解决方案是将逻辑上相关的类和对象放在同一个模块中，只暴露出其他模块必须看到的元素
- 分解为模块的总体目标是通过允许模块独立地设计和修改，从而减少软件的成本。每个模块的设计应该简单到能够被完全理解。修改设计的容易程度应该满足需要变更的可能性
- 开发者必须平衡两种竞争的技术考虑：封装抽象的愿望以及让其他模块看到某些抽象的需要

> 模块化的定义

- 模块化是一个系统的属性，这个系统被分解为一组高内聚、低耦合的模块

> 模块化设计决策

- 发现正确的类和对象，然后将它们放到不同的模块中，这基本上是独立的设计决定；类和对象的确定是系统逻辑设计的一部分，而模块的确定是系统物理设计的一部分
- 不能再物理设计之间完成所有逻辑设计，设计决策是以一种迭代的方式进行的

---

## 3.4 层次结构的意义

- 通过隐藏抽象的内部视图，封装有助于管理这种复杂性。一组抽象常常构成一个层次结构，通过在设计中确定这些层次结构，可以极大地简化对系统的理解

> 层次结构的定义

- 层次结构是抽象的一种分级或排序
- 在复杂系统中，最重要的两种层次结构是它的类结构（“是一种” 层次结构）和对象结构（“组成部分” 层次结构）

---
## 3.5 类型的意义

> 类型的定义

- 类型是关于一个对象的类的强制规定，不同类型的对象不能够互换使用，或者至少它们的互换使用受到非常严格的限制
- 类型匹配是类型概念的核心，强类型语言要求类型匹配是严格保证的。

> 动态类型与静态类型 

- 类型的强与弱和类型的静态与动态的概念是完全不同的，类型的强与弱指的是类型一致性，而类型的静态与动态指的是名字与类型绑定的时间
- 静态类型是编译时确定，动态类型是运行时绑定

---
## 3.6 并发的意义

- 重量级并发：重量级进程通常是由目标操作独立管理的，它有自己的地址空间
- 轻量级并发：轻量级进程通常与其他轻量级进程一起处于单个操作系统进程之内，共享同样的地址空间
- 并发在设计中常常要考虑死锁，活锁，饥饿，互斥和竞争条件等问题。对象模型适合于分布式系统，因为隐式地定义了发布和移动的单元以及实体的通信
- 面向对象编程关注数据抽象，但封装、继承和并发关注了过程抽象和同步

> 并发的定义

- 并发是一种属性，它区分了主动对象和非主动对象

> 并发的几种设计

- 并发是某种编程语言的内在特征，语言提供了并发和同步的机制
- 可以使用一个类库来实现某种形式的轻量级进程
- 可以利用中断来实现并发的假象

> 并发需要考虑的问题

- 当在一个系统中引入并发时，必须考虑主动对象之间、主动对象与纯粹串行执行的对象之间，如何同步它们的活动

---
## 3.7 持久的意义

- 统一对象和并发的概念导致了并发的面向对象程序设计语言；在对象模型中引入持久的概念导致了面向对象的数据库

> 对象持久的谱系

- 表达式计算的瞬时结果
- 过程执行时的局部变量
- 自有变量、全局变量、堆中的值，它们的存在时间与它们的有效范围不同
- 在程序执行之间存在的数据
- 在程序的不同版本之间存在的数据
- 比程序生命期长的数据

> 持久的定义

- 持久是对象的一种属性，利用这种属性，对象跨越时间（当对象的创建不存在了的时候，对象仍然存在）和空间（对象的位置从它被创建的地址空间移开）而存在

---
# 4. 应用对象模型

> 对象模型的好处

- 使用对象模型帮助我们探索基于对象和面向对象编程语言的表达能力
- 利用对象模型不仅鼓励软件的复用，而且鼓励整个设计的复用，这导致了可复用应用框架的产生
- 使用对象模型将得到构建在稳定的中间状态上的系统，这样的系统更适合变化
- 对象模型减少了开发复杂系统所固有的风险
- 对象模型引起了人类认知的工作的兴趣

---