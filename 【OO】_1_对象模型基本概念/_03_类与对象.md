# 类与对象

---

- [类与对象](#类与对象)
- [1. 对象的本质](#1-对象的本质)
	- [1.1 对象状态](#11-对象状态)
	- [1.2 对象行为](#12-对象行为)
	- [1.3 对象标识符](#13-对象标识符)
- [2. 对象之间的关系](#2-对象之间的关系)
	- [2.1 链接（link）](#21-链接link)
	- [2.2 聚合](#22-聚合)
- [3. 类的本质](#3-类的本质)
	- [3.1 类的定义](#31-类的定义)
	- [3.2 接口和实现](#32-接口和实现)
	- [3.3 类的生命周期](#33-类的生命周期)
- [4. 类之间的关系](#4-类之间的关系)
	- [4.1 关联](#41-关联)
	- [4.2 继承](#42-继承)
	- [4.3 聚合](#43-聚合)
	- [4.4 依赖关系](#44-依赖关系)
- [5. 类与对象的互动](#5-类与对象的互动)
- [6. 优质类的评判标准](#6-优质类的评判标准)

---
# 1. 对象的本质

- 一个对象是一个具有状态、行为和标识符的实体。结构和行为类似的对象定义在他们共同的类中。实例和对象这两个术语可以互换使用

---
## 1.1 对象状态

> 状态定义

- 对象的状态包括这个对象的所有属性（通常是静态的）以及每个属性当前的值（通常是动态的）
- 一个属性是一种内在或独特的特征、特点、品质或特征，使一个对象区别于别的对象

---
## 1.2 对象行为

> 行为定义

- 行为是对象在状态改变和消息传递方面的动作和反应的方式
- 一个对象的状态代表了它的行为的累积效果

> 一个操作代表了一个类提供给它的对象的一种服务

- 修改操作：更改一个对象的状态的操作
- 选择操作：访问一个对象的状态但并不更改这个状态的操作
- 遍历操作：以一种定义良好的方式访问一个对象的所有或部分的操作
- 构造操作：创建一个对象并初始化它的状态的操作
- 析构操作：释放一个对象的状态并销毁对象本身的操作

> 一个对象的所有方法共同构成了它的协议

- 责任意味着表达对象的一种目标以及它在系统中的位置。一个对象的责任是它为支持的所有契约提供的全部服务

> 对象中存在状态，这意味着操作调用的次序非常重要

- 主动的对象有自己的控制线程，而被动的对象则没有。主动的对象不需要由其他对象操作，就能表现一些行为；被动对象只有显式地操作时，才会发生状态变化

---
## 1.3 对象标识符

> 标识符定义

- 标识符是一个对象的属性，它区分这个对象与其他所有对象
- 每个对象的唯一标识符（不一定是名称）是在对象的整个生命周期中都被保持的，即使它的状态改变时也是如此

---
# 2. 对象之间的关系

## 2.1 链接（link）

- 链接定义为两个对象物理上或概念上的联系。一个对象通过它与其他对象的链接，与其他对象进行协作。

> 对象作为链接的参与者，常扮演的角色

- 控制器：这个对象可以操作其他对象，但不会被其他对象操作
- 服务器：这个对象不操作其他对象，它只被其他对象操作
- 代理：这个对象可以操作其他对象，也可以被其他对象操作

> 特征

- 可见性：A 与 B 之间存在一个链接，为了让 A 能向 B 发送一条消息，B 必须以某种方式让 A 能看到它
- 同步：当一个对象通过链接向另一个对象发送一条消息时，这两个对象就称为同步了。
- 当一个主动对象与一个被动对象之间有链接时，选择有三种同步方式
  - 顺序：只有在某一时刻只存在一个主动对象时，被动对象的语义才能得到保证
  - 守卫：在多个控制线程的程序下，被动对象的语义也能保证，但主动的客户之间必须协作，以实现互斥访问
  - 并发：在多个控制线程的程序下，被动对象的语义也能保证，服务提供者保证互斥

---
## 2.2 聚合

- 链接表明了一种端到端的关系或客户/服务提供者的关系，而聚合则表明了一种整体/部分层次结构，提供了从整体导航到它的部分的能力
- 如果一个对象是另一个对象的一部分，就意味着它到它的聚合体有一个链接

---
# 3. 类的本质

## 3.1 类的定义

- 对象是存在于时间和空间中的具体实体，而类仅代表一种抽象，即一个对象的本质。class 是由一些共同特征或一项共同特征所标识的一组、一群或一类，根据品质、资格或条件进行的分组、区分或分级
- 类是一组对象，它们拥有共同的结构、共同的行为和共同的语义

---
## 3.2 接口和实现

- 一个类的接口提供了它的外部视图，这个接口主要由所有的操作声明构成，这些操作适用于这个类的所有对象。
- 一个类的实现主要由类接口中定义的所有操作的实现构成

---
## 3.3 类的生命周期

- 类的每个实例的生命周期在不同阶段有不同的操作，由于这些实例具有共同的行为，可以通过类来描述这些共同的事件次序和时间次序语义

---
# 4. 类之间的关系

- 存在三种基本类型的类关系：一般/特殊关系，表示是一种关系；整体/部分关系，表示组成部分关系；关联关系，某种语义上的依赖关系

---
## 4.1 关联

> 特征

- 语义上的依赖关系：关联只代表一种语义上的依赖关系，它不表示这种依赖关系的方向，也不表示一个类与另一个类相关的具体形式
- 多重性：一对一、一对多、多对多；例如一对一的关系代表了非常有局限的关系

---
## 4.2 继承

- 继承是类之间的一种关系，一个类共享了另一个类（单继承）或多个类（多继承）中定义的结构和行为
- 子类通常扩展或限制了超类中原有的结构和行为。继承和封装之间存在这非常大的压力，继承暴露了被继承类的一些秘密；继承意味着子类继承了超类的结构，因此也继承了超类行为
- 子类扩展超类的能力，或覆写父类的操作，就实现了多态（类型理论的一个概念）。多态与延迟绑定是分不开的，在出现多态时，方法和名字的绑定要在执行时确定
- 多继承易出现方法或变量二义性，有三种基本方法可用来解决这种冲突：编译时拒绝编译、编译时同化、编译时重新限定；多继承应避免重复继承的问题

---
## 4.3 聚合

- 类之间的聚合关系与这些类的对象之间的聚合关系是共存的。存在两种形式的聚合方式：按值包容（物理包容，两个对象的生存期紧密联系）和按引用包容（生存期可以完全独立）

---
## 4.4 依赖关系

- 依赖关系表明，处于这种关系一端的元素以某种方式依赖于处于另一端的元素，其中一个元素发生改变，可能会影响到另一个元素（一个系统组件或包依赖于另一个组件或包，一个模块依赖于另一个模块）

---
# 5. 类与对象的互动

> 类与对象的关系

- 绝大多数对象的类是静态的，意味着对象一旦被创建，它的类就确定了。而对象通常在应用的生存期中频繁地被创建和销毁

> 类与对象在分析与设计中的角色

- 在分析阶段与设计的早期阶段，有两项主要任务：
  - 从问题域的词汇中确定出类
  - 创建一些结构，让多组对象一起工作，提供满足问题需求的行为

- 类和对象统称为问题的关键抽象，这些协作结构称为实现的机制。外部视图代表了系统的逻辑框架，包含了熊的类结构和对象结构。在设计后期，关注的焦点放在了抽象和机制的内部视图，包括它们的物理实现

---
# 6. 优质类的评判标准

- 系统应该利用一组最少的不会变化的部分进行构建，这些部分应该尽可能地通用，系统的所有部分应该被放入一个统一的框架

> 抽象的品质度量标准

- 耦合：一个模块与另一个模块之间建立起的关联强度的测量。强耦合使得系统变得复杂
- 内聚：内聚测量了单个模块内各个元素的联系程度。避免将完全无关的抽象塞进一个类或模块中
- 充分性：类或模块应该记录某个抽象足够多的特征。充分有助于允许有意义、有效的交互
- 完整性：类或模块的接口记录了某个抽象全部有意义的特征。完整的接口意味着该接口包含了某个抽象的所有方向
- 基础性：基础性操作就是只有访问该抽象的底层表现形式才能够有效地实现的那些操作

> 选择操作

- 功能语义：每个基础操作都应展示出小的、定义良好的行为。应倾向于分离方法，让它们相互之间不通信。
- 设计类时常考虑：可复用性、复杂性、适用性、实现知识（是否依赖于一个类型的内部细节）
- 时间和空间语义：必须决定某个操作需要的时间以及存储空间
  
> 选择关系

- Demeter 法则：类的方法不应该以任何方式依赖于任何类的结构，除了它自己类的当前（顶层）结构之外。每个方法只能够对一个非常有限的类集的对象发出消息
- 机制和可见性：决定对象之间的关系是设计这些对象进行交互的机制。要考虑这些知识（内部细节）应该放在哪些地方

> 选择实现

- 表现形式：类或对象的表现形式几乎总是该抽象封装起来的秘密。要求我们可以改变类和对象的表现形式的同时，不会改变类的外部视图
- 打包：在模块中声明类和对象，可见性与信息隐藏引导我们决定在哪里声明类和对象。在构建功能内聚的、松耦合的模块会影响这些决定。

---